import numpy as np
import heapq
import matplotlib.pyplot as plt
import math
import time


class AStarPathfinder:
    def __init__(self, map_grid):
        self.map_grid = map_grid  # map_grid to dwuwymiarowa tablica, gdzie 1 oznacza przeszkodę, a 0 wolne miejsce

    def heuristic(self, a, b):
        # Odległość euklidesowa
        return np.linalg.norm(np.array(a) - np.array(b))

    def astar(self, start, goal):
        # Kolejka priorytetowa
        open_list = []
        heapq.heappush(open_list, (0, start))

        came_from = {}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}

        while open_list:
            current = heapq.heappop(open_list)[1]

            if current == goal:
                return self.reconstruct_path(came_from, current)

            for neighbor in self.get_neighbors(current):
                tentative_g_score = g_score[current] + self.distance(current, neighbor)

                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)

                    if neighbor not in dict(open_list):
                        heapq.heappush(open_list, (f_score[neighbor], neighbor))

        return []  # Nie znaleziono ścieżki

    def get_neighbors(self, node):
        x, y = node
        neighbors = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]  # Ruchy w 4 kierunkach
        return [n for n in neighbors if self.is_valid(n)]

    def is_valid(self, node):
        x, y = node
        return 0 <= x < self.map_grid.shape[0] and 0 <= y < self.map_grid.shape[1] and self.map_grid[x, y] == 0

    def distance(self, a, b):
        return np.linalg.norm(np.array(a) - np.array(b))

    def reconstruct_path(self, came_from, current):
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        return path[::-1]

    def visualize_path(self, path, map_grid, robot_position=None, filename="path_visualization.png"):
        """
        Visualize the path on the map grid and optionally include the robot's position, with the path offset by the robot position.
        :param path: The list of points representing the path.
        :param map_grid: The grid map array to overlay the path on.
        :param robot_position: A tuple (x, y) representing the robot's position in grid coordinates.
        :param filename: The name of the output image file.
        """

        # Stworzenie wykresu
        plt.figure(figsize=(8, 8))

        # Wyświetlenie mapy siatki
        plt.imshow(map_grid, cmap='gray', origin='lower')

        # Rozpoczęcie i zakończenie ścieżki
        if path and robot_position:
            path = np.array(path)
            robot_x, robot_y = robot_position

            # Odjęcie współrzędnych robota od ścieżki, aby zcentrować na pozycji robota
            path[:, 0] -= robot_y
            path[:, 1] -= robot_x

            plt.plot(path[:, 1], path[:, 0], 'r-', lw=2, label='Path')

        # Dodanie pozycji robota jako kropki
        if robot_position:
            robot_x, robot_y = robot_position
            plt.plot(robot_x, robot_y, 'bo', markersize=10, label='Robot Position')

        plt.xlabel('X Coordinate')
        plt.ylabel('Y Coordinate')
        plt.title('Path Visualization')
        plt.legend()
        plt.grid(True)
        plt.savefig(filename)
        plt.close()

    def calculate_angle_and_distance(self, start, end):
        """
        Calculate the angle and distance between two points.
        :param start: Starting point (x1, y1)
        :param end: Ending point (x2, y2)
        :return: (angle, distance)
        """
        dx = end[0] - start[0]
        dy = end[1] - start[1]
        distance = math.sqrt(dx**2 + dy**2)
        angle = math.degrees(math.atan2(dy, dx))
        return angle, distance

    def move_robot_along_path(self, motor_controller, path, gyro, segment_length_cm=10):
        """
        Move the robot along the path generated by the A* algorithm with consideration of map units.
        :param motor_controller: MotorController object to control robot movement.
        :param path: List of points [(x1, y1), (x2, y2), ..., (xN, yN)] representing the path.
        :param gyro: Gyroscope object to track current orientation.
        :param segment_length_cm: Length of each segment in centimeters.
        """
        current_position = path[0]  # Start from the initial position

        # Convert segment_length_cm to meters
        segment_length_m = segment_length_cm * 0.01

        for target_position in path[1:]:  # Move towards each point in the path
            # Calculate angle and distance to the next point
            target_angle, target_distance = self.calculate_angle_and_distance(current_position, target_position)

            # Get current angle from gyroscope
            current_angle = gyro.get_angle_z()

            # Calculate the rotation required
            angle_to_rotate = target_angle - current_angle

            # Choose the direction of rotation
            direction = 'left' if angle_to_rotate < 0 else 'right'

            # Rotate the robot to face the target angle
            motor_controller.rotate_to_angle(gyro, target_angle=target_angle, direction=direction)
            time.sleep(0.5)
            # Move forward the calculated distance in segments
            while target_distance > 0:
                segment_distance = min(segment_length_m, target_distance)
                motor_controller.forward_with_encoders(segment_distance)
                target_distance -= segment_distance

            # Update current position
            current_position = target_position

            # Small delay to simulate real robot movement
            time.sleep(0.5)


